// Beanstalk Runtime System
//
// This module provides the runtime infrastructure for executing WASM generated by the Beanstalk compiler.
// It's designed to be pluggable and separate from the compiler itself, supporting multiple execution
// environments and IO backends.
pub mod backends {
    pub mod cranelift;
}
pub mod embedding;
pub mod io {
    pub mod custom;
    pub mod io;
    pub mod js_bindings;
    pub mod native;
}
pub mod jit;

use crate::compiler::compiler_errors::CompileError;
use crate::runtime::backends::cranelift::execute_with_cranelift;
use std::path::Path;

/// Runtime configuration for executing Beanstalk WASM
#[derive(Debug, Clone)]
pub struct RuntimeConfig {
    /// JIT compilation mode (Cranelift for dev, LLVM for release)
    pub compilation_mode: CompilationMode,
    /// IO backend configuration
    pub io_backend: IoBackend,
    /// Whether to enable hot reloading for embedded scenarios
    pub hot_reload: bool,
    /// Additional runtime flags
    pub flags: Vec<RuntimeFlag>,
}

#[derive(Debug, Clone)]
pub enum CompilationMode {
    /// Fast compilation using Cranelift with optimization level
    Cranelift(CraneliftOptLevel),
    /// Optimized compilation using LLVM (release builds) - Maybe in the future if Cranelift implements it (currently experimental in Wasmer)
    // Llvm,
    /// Direct JIT execution without further compilation
    DirectJit,

    // Just directly output the Wasm - no further backend steps
    // Fastest for hotreloading web projects or for feeding the Wasm output into different custom backends
    None,
    // Wasm-opt (outputs optimised wasm files for web)
    // TODO: Use wasm-opt library?
}

/// Cranelift optimization levels
#[derive(Debug, Clone)]
pub enum CraneliftOptLevel {
    /// No optimization - fastest compilation (development/hot-reload)
    None,
    /// Optimize for speed (native release builds)
    Speed,
    /// Optimize for both speed and size (HTML/web builds)
    SpeedAndSize,
}

#[derive(Debug, Clone)]
pub enum IoBackend {
    /// Standard WASI interface
    Wasi,
    /// Custom IO hooks for embedded scenarios
    Custom(String), // Configuration path or identifier
    /// JavaScript/DOM bindings for web targets
    JsBindings,
    /// Native system calls
    Native,
}

#[derive(Debug, Clone)]
pub enum RuntimeFlag {
    /// Enable verbose runtime logging
    Verbose,
    /// Enable performance profiling
    Profile,
    /// Enable debug mode
    Debug,
}

impl Default for RuntimeConfig {
    fn default() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::Speed),
            io_backend: IoBackend::Wasi,
            hot_reload: false,
            flags: vec![],
        }
    }
}

impl RuntimeConfig {
    /// Create configuration optimized for development (fast compilation, hot reload)
    pub fn for_development() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::None),
            io_backend: IoBackend::Native,
            hot_reload: true,
            flags: vec![RuntimeFlag::Debug],
        }
    }

    /// Create configuration optimized for native release builds (speed optimization)
    pub fn for_native_release() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::Speed),
            io_backend: IoBackend::Native,
            hot_reload: false,
            flags: vec![],
        }
    }

    /// Create configuration optimized for HTML/web builds (size and speed optimization)
    pub fn for_html_release() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::SpeedAndSize),
            io_backend: IoBackend::JsBindings,
            hot_reload: false,
            flags: vec![],
        }
    }

    /// Create configuration for embedded scenarios
    pub fn for_embedded(hot_reload: bool) -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(if hot_reload {
                CraneliftOptLevel::None
            } else {
                CraneliftOptLevel::Speed
            }),
            io_backend: IoBackend::Custom("embedded".to_string()),
            hot_reload,
            flags: if hot_reload {
                vec![RuntimeFlag::Debug]
            } else {
                vec![]
            },
        }
    }
}

/// Main runtime interface for executing Beanstalk WASM
pub struct BeanstalkRuntime {
    config: RuntimeConfig,
}

impl BeanstalkRuntime {
    pub fn new(config: RuntimeConfig) -> Self {
        Self { config }
    }

    /// Execute WASM bytecode with the configured runtime
    pub fn execute(&self, wasm_bytes: &[u8]) -> Result<(), CompileError> {
        match &self.config.compilation_mode {
            CompilationMode::DirectJit => jit::execute_direct_jit(wasm_bytes, &self.config),
            CompilationMode::Cranelift(opt_level) => {
                execute_with_cranelift(wasm_bytes, &self.config, &opt_level)
            }
            _ => unimplemented!(),
        }
    }

    /// Execute WASM from a file path
    pub fn execute_file(&self, wasm_path: &Path) -> Result<(), CompileError> {
        let wasm_bytes = std::fs::read(wasm_path).map_err(|e| {
            CompileError::file_error(wasm_path, &format!("Failed to read WASM file: {}", e))
        })?;

        self.execute(&wasm_bytes)
    }

    /// Create runtime for embedding in Rust applications
    pub fn create_embedded_runtime(&self) -> Result<embedding::EmbeddedRuntime, CompileError> {
        embedding::EmbeddedRuntime::new(&self.config)
    }
}
