// Beanstalk Runtime System
//
// This module provides the runtime infrastructure for executing WASM generated by the Beanstalk compiler.
// It's designed to be pluggable and separate from the compiler itself, supporting multiple execution
// environments and IO backends.
pub mod backends {
    pub mod cranelift;
}
pub mod embedding;
pub mod io {
    pub mod custom;
    pub mod io;
    pub mod js_bindings;
    pub mod native;
}
pub mod jit;
pub mod memory_utils;

use crate::compiler::compiler_errors::CompileError;
use crate::runtime::backends::cranelift::execute_with_cranelift;
use std::path::Path;

/// Runtime configuration for executing Beanstalk WASM
#[derive(Debug, Clone)]
pub struct RuntimeConfig {
    /// JIT compilation mode (Cranelift for dev, LLVM for release)
    pub compilation_mode: CompilationMode,
    /// IO backend configuration
    pub io_backend: IoBackend,
    /// Whether to enable hot reloading for embedded scenarios
    pub hot_reload: bool,
    /// Additional runtime flags
    pub flags: Vec<RuntimeFlag>,
}

#[derive(Debug, Clone)]
pub enum CompilationMode {
    /// Fast compilation using Cranelift with optimization level
    Cranelift(CraneliftOptLevel),
    /// Optimized compilation using LLVM (release builds) - Maybe in the future if Cranelift implements it (currently experimental in Wasmer)
    // Llvm,
    /// Direct JIT execution without further compilation
    DirectJit,

    // Just directly output the Wasm - no further backend steps
    // Fastest for hotreloading web projects or for feeding the Wasm output into different custom backends
    None,
    // Wasm-opt (outputs optimised wasm files for web)
    // TODO: Use wasm-opt library?
}

/// Cranelift optimization levels
#[derive(Debug, Clone)]
pub enum CraneliftOptLevel {
    /// No optimization - fastest compilation (development/hot-reload)
    None,
    /// Optimize for speed (native release builds)
    Speed,
    /// Optimize for both speed and size (HTML/web builds)
    SpeedAndSize,
}

#[derive(Debug, Clone)]
pub enum IoBackend {
    /// Standard WASIX interface
    Wasix,
    /// Custom IO hooks for embedded scenarios
    Custom(String), // Configuration path or identifier
    /// JavaScript/DOM bindings for web targets
    JsBindings,
    /// Native system calls
    Native,
}

#[derive(Debug, Clone)]
pub enum RuntimeFlag {
    /// Enable verbose runtime logging
    Verbose,
    /// Enable performance profiling
    Profile,
    /// Enable debug mode
    Debug,
}

impl Default for RuntimeConfig {
    fn default() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::Speed),
            io_backend: IoBackend::Wasix,
            hot_reload: false,
            flags: vec![],
        }
    }
}

impl RuntimeConfig {
    /// Create configuration optimized for development (fast compilation, hot reload)
    pub fn for_development() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::None),
            io_backend: IoBackend::Wasix, // Use WASIX for enhanced system call support
            hot_reload: true,
            flags: vec![RuntimeFlag::Debug],
        }
    }

    /// Create configuration optimized for native release builds (speed optimization)
    pub fn for_native_release() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::Speed),
            io_backend: IoBackend::Wasix, // Use WASIX for enhanced system call support
            hot_reload: false,
            flags: vec![],
        }
    }

    /// Create configuration optimized for HTML/web builds (size and speed optimization)
    pub fn for_html_release() -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(CraneliftOptLevel::SpeedAndSize),
            io_backend: IoBackend::JsBindings,
            hot_reload: false,
            flags: vec![],
        }
    }

    /// Create configuration for embedded scenarios
    pub fn for_embedded(hot_reload: bool) -> Self {
        Self {
            compilation_mode: CompilationMode::Cranelift(if hot_reload {
                CraneliftOptLevel::None
            } else {
                CraneliftOptLevel::Speed
            }),
            io_backend: IoBackend::Custom("embedded".to_string()),
            hot_reload,
            flags: if hot_reload {
                vec![RuntimeFlag::Debug]
            } else {
                vec![]
            },
        }
    }
}

/// Main runtime interface for executing Beanstalk WASM
pub struct BeanstalkRuntime {
    config: RuntimeConfig,
}

impl BeanstalkRuntime {
    pub fn new(config: RuntimeConfig) -> Self {
        Self { config }
    }

    /// Execute WASM bytecode with the configured runtime
    pub fn execute(&self, wasm_bytes: &[u8]) -> Result<(), CompileError> {
        match &self.config.compilation_mode {
            CompilationMode::DirectJit => {
                // Check if we should use WASIX-specific runtime
                match &self.config.io_backend {
                    IoBackend::Wasix => {
                        // Use WASIX-specific runtime with native function support
                        jit::execute_wasm_with_wasix_runtime(wasm_bytes, &self.config)
                    }
                    _ => {
                        // Use standard JIT execution
                        jit::execute_direct_jit(wasm_bytes, &self.config)
                    }
                }
            }
            CompilationMode::Cranelift(opt_level) => {
                execute_with_cranelift(wasm_bytes, &self.config, &opt_level)
            }
            _ => unimplemented!(),
        }
    }

    /// Execute WASM from a file path
    pub fn execute_file(&self, wasm_path: &Path) -> Result<(), CompileError> {
        let wasm_bytes = std::fs::read(wasm_path).map_err(|e| {
            let error_msg: &'static str = Box::leak(format!("Failed to read WASM file: {}", e).into_boxed_str());
            let suggestion: &'static str = if e.kind() == std::io::ErrorKind::NotFound {
                "Check that the WASM file exists at the specified path"
            } else if e.kind() == std::io::ErrorKind::PermissionDenied {
                "Check that you have permission to read the WASM file"
            } else {
                "Verify the WASM file is accessible and not corrupted"
            };
            
            CompileError::new_file_error(
                wasm_path,
                error_msg,
                {
                    let mut map = std::collections::HashMap::new();
                    map.insert(crate::compiler::compiler_errors::ErrorMetaDataKey::CompilationStage, "Runtime");
                    map.insert(crate::compiler::compiler_errors::ErrorMetaDataKey::PrimarySuggestion, suggestion);
                    map
                }
            )
        })?;

        self.execute(&wasm_bytes)
    }

    /// Create runtime for embedding in Rust applications
    pub fn create_embedded_runtime(&self) -> Result<embedding::EmbeddedRuntime, CompileError> {
        embedding::EmbeddedRuntime::new(&self.config)
    }
}
