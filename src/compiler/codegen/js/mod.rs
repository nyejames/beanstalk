//! JavaScript codegen for Beanstalk HIR.
//!
//! Lowers HIR into a standalone JS module with GC-only semantics.

use crate::compiler::compiler_errors::CompilerError;
use crate::compiler::datatypes::DataType;
use crate::compiler::hir::nodes::{
    BinOp, BlockId, HirBlock, HirExpr, HirExprKind, HirKind, HirModule, HirPlace, HirStmt,
    HirTerminator, UnaryOp,
};
use crate::compiler::parsers::ast_nodes::Var;
use crate::compiler::string_interning::{InternedString, StringTable};
use crate::return_compiler_error;
use crate::settings::IMPLICIT_START_FUNC_NAME;
use std::collections::{HashMap, HashSet, VecDeque};

const INDENT: &str = "    ";
const BLOCK_VAR: &str = "__bst_block";
const TEMPLATE_RESULTS_VAR: &str = "__bst_template_results";
const TEMPLATE_OUTPUT_VAR: &str = "__bst_out";
const HOST_VAR: &str = "__bst_host";
const HOST_IO_FN: &str = "__bst_host_io_functions";
const STRINGIFY_FN: &str = "__bst_stringify";

#[derive(Debug, Clone)]
pub struct JsModule {
    pub source: String,
    pub entry_function: Option<String>,
    pub exports: Vec<String>,
}

pub fn lower_hir_to_js(
    hir_module: &HirModule,
    string_table: &StringTable,
) -> Result<JsModule, CompilerError> {
    let mut context = JsCodegenContext::new(string_table);
    context.emit_module(hir_module)
}

struct JsCodegenContext<'a> {
    string_table: &'a StringTable,
    identifiers: JsIdentifierMap,
    output: String,
    indent: usize,
    flags: PreludeFlags,
    exports: Vec<String>,
    entry_function: Option<String>,
}

#[derive(Default)]
struct PreludeFlags {
    uses_host: bool,
    uses_host_io: bool,
    uses_stringify: bool,
}

impl<'a> JsCodegenContext<'a> {
    fn new(string_table: &'a StringTable) -> Self {
        let mut identifiers = JsIdentifierMap::new();
        identifiers.reserve(BLOCK_VAR);
        identifiers.reserve(TEMPLATE_RESULTS_VAR);
        identifiers.reserve(TEMPLATE_OUTPUT_VAR);
        identifiers.reserve(HOST_VAR);
        identifiers.reserve(HOST_IO_FN);
        identifiers.reserve(STRINGIFY_FN);

        JsCodegenContext {
            string_table,
            identifiers,
            output: String::new(),
            indent: 0,
            flags: PreludeFlags::default(),
            exports: Vec::new(),
            entry_function: None,
        }
    }

    fn emit_module(mut self, hir_module: &HirModule) -> Result<JsModule, CompilerError> {
        for node in &hir_module.structs {
            if let HirKind::Stmt(HirStmt::StructDef { name, fields }) = &node.kind {
                self.emit_struct_def(*name, fields)?;
            }
        }

        for node in &hir_module.functions {
            match &node.kind {
                HirKind::Stmt(HirStmt::FunctionDef {
                    name,
                    signature,
                    body,
                }) => {
                    let raw_name = self.string_table.resolve(*name);
                    let js_name = self.identifiers.get(*name, self.string_table);
                    if raw_name == IMPLICIT_START_FUNC_NAME {
                        self.entry_function = Some(js_name.to_owned());
                        self.exports.push(js_name.to_owned());
                    }
                    self.emit_function_def(*name, signature, *body, hir_module.blocks.as_slice())?;
                }
                HirKind::Stmt(HirStmt::TemplateFn { name, params, body }) => {
                    self.flags.uses_stringify = true;
                    self.emit_template_fn(*name, params, *body, hir_module.blocks.as_slice())?;
                }
                _ => {}
            }
        }

        if !self.exports.is_empty() {
            let exports = self.exports.join(", ");
            self.write_line(&format!("export {{ {} }};", exports));
        }

        let mut source = String::new();
        source.push_str(&self.render_prelude());
        source.push_str(&self.output);

        Ok(JsModule {
            source,
            entry_function: self.entry_function,
            exports: self.exports,
        })
    }

    fn render_prelude(&self) -> String {
        let mut prelude = String::new();

        prelude.push_str("// Generated by the Beanstalk compiler.\n");

        if self.flags.uses_host || self.flags.uses_host_io {
            prelude.push_str(&format!(
                "const {} = globalThis.__beanstalk_host || {{}};\n",
                HOST_VAR
            ));
        }

        if self.flags.uses_stringify {
            prelude.push_str(&format!(
                "function {}(value) {{\n{}return value == null ? \"\" : String(value);\n}}\n",
                STRINGIFY_FN, INDENT
            ));
        }

        if self.flags.uses_host_io {
            prelude.push_str(&format!(
                "function {}(value) {{\n{}const io = {}.beanstalk_io;\n{}if (io && typeof io.host_io_functions === \"function\") {{\n{}{}return io.host_io_functions(value);\n{}}}\n{}console.log(String(value));\n}}\n",
                HOST_IO_FN,
                INDENT,
                HOST_VAR,
                INDENT,
                INDENT,
                INDENT,
                INDENT,
                INDENT
            ));
        }

        prelude.push('\n');

        prelude
    }

    fn emit_struct_def(&mut self, name: InternedString, fields: &[Var]) -> Result<(), CompilerError> {
        let js_name = self.identifiers.get(name, self.string_table);
        self.write_line(&format!("function {}(init) {{", js_name));
        self.indent += 1;
        self.write_line("const value = init || {};");
        self.write_line("return {");
        self.indent += 1;
        for field in fields {
            let field_name = self.string_table.resolve(field.id);
            let property = format_js_property_name(field_name);
            self.write_line(&format!("{}: value[{}],", property, format_js_string(field_name)));
        }
        self.indent -= 1;
        self.write_line("};");
        self.indent -= 1;
        self.write_line("}");
        self.write_line("");
        Ok(())
    }

    fn emit_function_def(
        &mut self,
        name: InternedString,
        signature: &crate::compiler::parsers::statements::functions::FunctionSignature,
        body: BlockId,
        blocks: &[HirBlock],
    ) -> Result<(), CompilerError> {
        let param_ids: Vec<InternedString> = signature
            .parameters
            .iter()
            .map(|param| param.id)
            .collect();
        let params = param_ids
            .iter()
            .map(|param| self.identifiers.get(*param, self.string_table))
            .collect::<Vec<_>>()
            .join(", ");

        let analysis = self.analyze_function(body, blocks, &param_ids)?;
        let js_name = self.identifiers.get(name, self.string_table);

        self.write_line(&format!("function {}({}) {{", js_name, params));
        self.indent += 1;
        self.emit_function_locals(&analysis, &param_ids)?;
        self.emit_block_dispatch(body, blocks, &analysis, false)?;
        self.indent -= 1;
        self.write_line("}");
        self.write_line("");
        Ok(())
    }

    fn emit_template_fn(
        &mut self,
        name: InternedString,
        params: &[(InternedString, DataType)],
        body: BlockId,
        blocks: &[HirBlock],
    ) -> Result<(), CompilerError> {
        let param_ids: Vec<InternedString> = params.iter().map(|(id, _)| *id).collect();
        let params = param_ids
            .iter()
            .map(|param| self.identifiers.get(*param, self.string_table))
            .collect::<Vec<_>>()
            .join(", ");

        let analysis = self.analyze_function(body, blocks, &param_ids)?;
        let js_name = self.identifiers.get(name, self.string_table);

        self.write_line(&format!("function {}({}) {{", js_name, params));
        self.indent += 1;
        self.write_line(&format!("let {} = \"\";", TEMPLATE_OUTPUT_VAR));
        self.emit_function_locals(&analysis, &param_ids)?;
        self.emit_block_dispatch(body, blocks, &analysis, true)?;
        self.indent -= 1;
        self.write_line("}");
        self.write_line("");
        Ok(())
    }

    fn emit_function_locals(
        &mut self,
        analysis: &FunctionAnalysis,
        params: &[InternedString],
    ) -> Result<(), CompilerError> {
        let mut local_names = Vec::new();
        let params_set: HashSet<InternedString> = params.iter().copied().collect();

        for local in &analysis.locals {
            if params_set.contains(local) {
                continue;
            }
            local_names.push(self.identifiers.get(*local, self.string_table));
        }

        local_names.sort();

        if analysis.uses_template_results {
            self.write_line(&format!(
                "const {} = Object.create(null);",
                TEMPLATE_RESULTS_VAR
            ));
        }

        if !local_names.is_empty() {
            let locals = local_names.join(", ");
            self.write_line(&format!("let {};", locals));
        }

        Ok(())
    }

    fn emit_block_dispatch(
        &mut self,
        entry: BlockId,
        blocks: &[HirBlock],
        analysis: &FunctionAnalysis,
        template_mode: bool,
    ) -> Result<(), CompilerError> {
        let mut block_ids = analysis.block_ids.to_owned();
        block_ids.sort_unstable();

        self.write_line(&format!("let {} = {};", BLOCK_VAR, entry));
        self.write_line("while (true) {");
        self.indent += 1;
        self.write_line(&format!("switch ({}) {{", BLOCK_VAR));
        self.indent += 1;

        for block_id in block_ids {
            let block = self.get_block(blocks, block_id)?;
            self.write_line(&format!("case {}:", block_id));
            self.indent += 1;
            self.emit_block_body(block_id, block, blocks, template_mode)?;
            self.indent -= 1;
        }

        self.write_line("default:");
        self.indent += 1;
        self.write_line(&format!(
            "throw new Error(\"Invalid block id: \" + {});",
            BLOCK_VAR
        ));
        self.indent -= 1;
        self.write_line("}");
        self.indent -= 1;
        self.write_line("}");
        Ok(())
    }

    fn emit_block_body(
        &mut self,
        block_id: BlockId,
        block: &HirBlock,
        blocks: &[HirBlock],
        template_mode: bool,
    ) -> Result<(), CompilerError> {
        let mut saw_terminator = false;

        for (index, node) in block.nodes.iter().enumerate() {
            match &node.kind {
                HirKind::Stmt(stmt) => {
                    self.emit_stmt(stmt, template_mode)?;
                }
                HirKind::Terminator(term) => {
                    if index + 1 != block.nodes.len() {
                        return_compiler_error!(
                            "HIR block {} contains nodes after a terminator",
                            block_id
                        );
                    }
                    self.emit_terminator(term, block_id, blocks, template_mode)?;
                    saw_terminator = true;
                }
            }
        }

        if !saw_terminator {
            if template_mode {
                self.write_line(&format!("return {};", TEMPLATE_OUTPUT_VAR));
            } else {
                self.write_line("return;");
            }
        }

        Ok(())
    }

    fn emit_stmt(&mut self, stmt: &HirStmt, template_mode: bool) -> Result<(), CompilerError> {
        match stmt {
            HirStmt::Assign {
                target,
                value,
                is_mutable: _,
            } => {
                let target_expr = self.emit_place(target)?;
                let value_expr = self.emit_expr(value)?;
                self.write_line(&format!("{} = {};", target_expr, value_expr));
            }
            HirStmt::Call { target, args } => {
                let call = self.emit_call_expr(*target, args)?;
                self.write_line(&format!("{};", call));
            }
            HirStmt::HostCall {
                module,
                import,
                args,
                ..
            } => {
                let call = self.emit_host_call(*module, *import, args)?;
                self.write_line(&format!("{};", call));
            }
            HirStmt::PossibleDrop(_) => {}
            HirStmt::RuntimeTemplateCall {
                template_fn,
                captures,
                ..
            } => {
                let template_name = self.string_table.resolve(*template_fn);
                let template_key = format_js_string(template_name);
                let call = self.emit_call_expr(*template_fn, captures)?;
                self.write_line(&format!(
                    "{}[{}] = {};",
                    TEMPLATE_RESULTS_VAR, template_key, call
                ));
            }
            HirStmt::TemplateFn { .. } | HirStmt::FunctionDef { .. } | HirStmt::StructDef { .. } => {
                return_compiler_error!("Nested definition statements are not supported in JS codegen");
            }
            HirStmt::ExprStmt(expr) => {
                let expr_str = self.emit_expr(expr)?;
                if template_mode {
                    self.flags.uses_stringify = true;
                    self.write_line(&format!(
                        "{} += {}({});",
                        TEMPLATE_OUTPUT_VAR, STRINGIFY_FN, expr_str
                    ));
                } else {
                    self.write_line(&format!("{};", expr_str));
                }
            }
        }

        Ok(())
    }

    fn emit_terminator(
        &mut self,
        terminator: &HirTerminator,
        block_id: BlockId,
        blocks: &[HirBlock],
        template_mode: bool,
    ) -> Result<(), CompilerError> {
        match terminator {
            HirTerminator::If {
                condition,
                then_block,
                else_block,
            } => {
                let else_target = if let Some(else_block) = else_block {
                    *else_block
                } else {
                    self.infer_if_fallthrough(*then_block, blocks)?
                };
                let cond_expr = self.emit_expr(condition)?;
                self.write_line(&format!("if ({}) {{", cond_expr));
                self.indent += 1;
                self.write_line(&format!("{} = {};", BLOCK_VAR, then_block));
                self.indent -= 1;
                self.write_line("} else {");
                self.indent += 1;
                self.write_line(&format!("{} = {};", BLOCK_VAR, else_target));
                self.indent -= 1;
                self.write_line("}");
                self.write_line("continue;");
            }
            HirTerminator::Break { target } | HirTerminator::Continue { target } => {
                self.write_line(&format!("{} = {};", BLOCK_VAR, target));
                self.write_line("continue;");
            }
            HirTerminator::Return(values) => {
                if values.is_empty() {
                    if template_mode {
                        self.write_line(&format!("return {};", TEMPLATE_OUTPUT_VAR));
                    } else {
                        self.write_line("return;");
                    }
                } else if values.len() == 1 {
                    let value = self.emit_expr(&values[0])?;
                    self.write_line(&format!("return {};", value));
                } else {
                    let value_list = values
                        .iter()
                        .map(|value| self.emit_expr(value))
                        .collect::<Result<Vec<_>, _>>()?
                        .join(", ");
                    self.write_line(&format!("return [{}];", value_list));
                }
            }
            HirTerminator::ReturnError(expr) => {
                let value = self.emit_expr(expr)?;
                self.write_line(&format!("throw {};", value));
            }
            HirTerminator::Panic { message } => {
                if let Some(expr) = message {
                    let value = self.emit_expr(expr)?;
                    self.write_line(&format!("throw new Error({});", value));
                } else {
                    self.write_line("throw new Error(\"panic\");");
                }
            }
            HirTerminator::Loop { .. } => {
                return_compiler_error!(
                    "JS codegen does not yet support HIR for-loop terminators (block {})",
                    block_id
                );
            }
            HirTerminator::Match { .. } => {
                return_compiler_error!(
                    "JS codegen does not yet support HIR match terminators (block {})",
                    block_id
                );
            }
        }

        Ok(())
    }

    fn emit_call_expr(
        &mut self,
        target: InternedString,
        args: &[HirExpr],
    ) -> Result<String, CompilerError> {
        let raw_name = self.string_table.resolve(target);
        let args_str = args
            .iter()
            .map(|arg| self.emit_expr(arg))
            .collect::<Result<Vec<_>, _>>()?
            .join(", ");

        if raw_name == "host_io_functions" {
            self.flags.uses_host = true;
            self.flags.uses_host_io = true;
            return Ok(format!("{}({})", HOST_IO_FN, args_str));
        }

        let js_name = self.identifiers.get(target, self.string_table);
        Ok(format!("{}({})", js_name, args_str))
    }

    fn emit_host_call(
        &mut self,
        module: InternedString,
        import: InternedString,
        args: &[HirExpr],
    ) -> Result<String, CompilerError> {
        self.flags.uses_host = true;
        let module_name = self.string_table.resolve(module);
        let import_name = self.string_table.resolve(import);
        let args_str = args
            .iter()
            .map(|arg| self.emit_expr(arg))
            .collect::<Result<Vec<_>, _>>()?
            .join(", ");
        Ok(format!(
            "{}[{}][{}]({})",
            HOST_VAR,
            format_js_string(module_name),
            format_js_string(import_name),
            args_str
        ))
    }

    fn emit_expr(&mut self, expr: &HirExpr) -> Result<String, CompilerError> {
        match &expr.kind {
            HirExprKind::Int(value) => {
                if matches!(expr.data_type, DataType::None) {
                    Ok("null".to_owned())
                } else {
                    Ok(value.to_string())
                }
            }
            HirExprKind::Float(value) => Ok(value.to_string()),
            HirExprKind::Bool(value) => Ok(value.to_string()),
            HirExprKind::StringLiteral(value) => {
                let raw = self.string_table.resolve(*value);
                Ok(format_js_string(raw))
            }
            HirExprKind::HeapString(template_fn) => {
                let raw = self.string_table.resolve(*template_fn);
                let key = format_js_string(raw);
                Ok(format!("{}[{}]", TEMPLATE_RESULTS_VAR, key))
            }
            HirExprKind::Char(value) => Ok(format_js_string(&value.to_string())),
            HirExprKind::Load(place) | HirExprKind::Move(place) => self.emit_place(place),
            HirExprKind::Field { base, field } => {
                let base_name = self.identifiers.get(*base, self.string_table);
                let field_name = self.string_table.resolve(*field);
                Ok(format_property_access(&base_name, field_name))
            }
            HirExprKind::BinOp { left, op, right } => {
                let left_expr = self.emit_expr(left)?;
                let right_expr = self.emit_expr(right)?;
                Ok(format_bin_op(&left_expr, *op, &right_expr))
            }
            HirExprKind::UnaryOp { op, operand } => {
                let operand_expr = self.emit_expr(operand)?;
                Ok(format_unary_op(*op, &operand_expr))
            }
            HirExprKind::Call { target, args } => self.emit_call_expr(*target, args),
            HirExprKind::MethodCall {
                receiver,
                method,
                args,
            } => {
                let receiver_expr = self.emit_expr(receiver)?;
                let method_name = self.string_table.resolve(*method);
                let method_expr = format_property_access(&receiver_expr, method_name);
                let args_str = args
                    .iter()
                    .map(|arg| self.emit_expr(arg))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("{}({})", method_expr, args_str))
            }
            HirExprKind::StructConstruct { type_name, fields } => {
                let struct_name = self.identifiers.get(*type_name, self.string_table);
                let mut field_parts = Vec::new();
                for (field_name, value) in fields {
                    let prop = format_js_property_name(self.string_table.resolve(*field_name));
                    let value_expr = self.emit_expr(value)?;
                    field_parts.push(format!("{}: {}", prop, value_expr));
                }
                Ok(format!(
                    "{}({{{}}})",
                    struct_name,
                    field_parts.join(", ")
                ))
            }
            HirExprKind::Collection(items) => {
                let items_str = items
                    .iter()
                    .map(|item| self.emit_expr(item))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("[{}]", items_str))
            }
            HirExprKind::Range { start, end } => {
                let start_expr = self.emit_expr(start)?;
                let end_expr = self.emit_expr(end)?;
                Ok(format!("({{ start: {}, end: {} }})", start_expr, end_expr))
            }
        }
    }

    fn emit_place(&mut self, place: &HirPlace) -> Result<String, CompilerError> {
        match place {
            HirPlace::Var(name) => Ok(self.identifiers.get(*name, self.string_table)),
            HirPlace::Field { base, field } => {
                let base_expr = self.emit_place(base)?;
                let field_name = self.string_table.resolve(*field);
                Ok(format_property_access(&base_expr, field_name))
            }
            HirPlace::Index { base, index } => {
                let base_expr = self.emit_place(base)?;
                let index_expr = self.emit_expr(index)?;
                Ok(format!("({})[{}]", base_expr, index_expr))
            }
        }
    }

    fn analyze_function(
        &self,
        entry: BlockId,
        blocks: &[HirBlock],
        params: &[InternedString],
    ) -> Result<FunctionAnalysis, CompilerError> {
        let block_ids = collect_reachable_blocks(entry, blocks)?;
        let mut locals = HashSet::new();
        let mut uses_template_results = false;
        let params_set: HashSet<InternedString> = params.iter().copied().collect();

        for block_id in &block_ids {
            let block = self.get_block(blocks, *block_id)?;
            for node in &block.nodes {
                match &node.kind {
                    HirKind::Stmt(stmt) => match stmt {
                        HirStmt::Assign { target, value, .. } => {
                            if let HirPlace::Var(name) = target {
                                if !params_set.contains(name) {
                                    locals.insert(*name);
                                }
                            }
                            scan_expr(value, &mut uses_template_results);
                        }
                        HirStmt::Call { args, .. } | HirStmt::HostCall { args, .. } => {
                            for arg in args {
                                scan_expr(arg, &mut uses_template_results);
                            }
                        }
                        HirStmt::RuntimeTemplateCall { captures, .. } => {
                            uses_template_results = true;
                            for capture in captures {
                                scan_expr(capture, &mut uses_template_results);
                            }
                        }
                        HirStmt::ExprStmt(expr) => {
                            scan_expr(expr, &mut uses_template_results);
                        }
                        HirStmt::PossibleDrop(_) => {}
                        HirStmt::TemplateFn { .. }
                        | HirStmt::FunctionDef { .. }
                        | HirStmt::StructDef { .. } => {}
                    },
                    HirKind::Terminator(term) => {
                        scan_terminator(term, &mut locals, &mut uses_template_results, &params_set);
                    }
                }
            }
        }

        let mut locals_vec: Vec<InternedString> = locals.into_iter().collect();
        locals_vec.sort_by(|left, right| {
            self.string_table
                .resolve(*left)
                .cmp(self.string_table.resolve(*right))
        });

        Ok(FunctionAnalysis {
            block_ids,
            locals: locals_vec,
            uses_template_results,
        })
    }

    fn get_block<'b>(&self, blocks: &'b [HirBlock], id: BlockId) -> Result<&'b HirBlock, CompilerError> {
        blocks.get(id).ok_or_else(|| {
            CompilerError::compiler_error(format!("Invalid HIR block id {}", id))
        })
    }

    fn infer_if_fallthrough(
        &self,
        then_block: BlockId,
        blocks: &[HirBlock],
    ) -> Result<BlockId, CompilerError> {
        let block = self.get_block(blocks, then_block)?;
        for node in block.nodes.iter().rev() {
            if let HirKind::Terminator(HirTerminator::Break { target }) = &node.kind {
                return Ok(*target);
            }
        }
        return_compiler_error!(
            "Cannot infer else target for if statement (then block {})",
            then_block
        )
    }

    fn write_line(&mut self, line: &str) {
        if line.is_empty() {
            self.output.push('\n');
            return;
        }
        for _ in 0..self.indent {
            self.output.push_str(INDENT);
        }
        self.output.push_str(line);
        self.output.push('\n');
    }
}

#[derive(Debug, Clone)]
struct FunctionAnalysis {
    block_ids: Vec<BlockId>,
    locals: Vec<InternedString>,
    uses_template_results: bool,
}

struct JsIdentifierMap {
    map: HashMap<InternedString, String>,
    used: HashSet<String>,
}

impl JsIdentifierMap {
    fn new() -> Self {
        JsIdentifierMap {
            map: HashMap::new(),
            used: HashSet::new(),
        }
    }

    fn reserve(&mut self, name: &str) {
        self.used.insert(name.to_owned());
    }

    fn get(&mut self, id: InternedString, table: &StringTable) -> String {
        if let Some(existing) = self.map.get(&id) {
            return existing.to_owned();
        }

        let raw = table.resolve(id);
        let mut candidate = sanitize_identifier(raw);

        if self.used.contains(&candidate) {
            let mut suffix = 1;
            let base = candidate.to_owned();
            loop {
                let next = format!("{}_{}", base, suffix);
                if !self.used.contains(&next) {
                    candidate = next;
                    break;
                }
                suffix += 1;
            }
        }

        self.used.insert(candidate.to_owned());
        self.map.insert(id, candidate.to_owned());
        candidate
    }
}

fn collect_reachable_blocks(
    entry: BlockId,
    blocks: &[HirBlock],
) -> Result<Vec<BlockId>, CompilerError> {
    if blocks.get(entry).is_none() {
        return_compiler_error!("Invalid entry block id {}", entry);
    }

    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    queue.push_back(entry);

    while let Some(block_id) = queue.pop_front() {
        if !visited.insert(block_id) {
            continue;
        }
        let block = blocks.get(block_id).ok_or_else(|| {
            CompilerError::compiler_error(format!("Invalid HIR block id {}", block_id))
        })?;
        for succ in block_successors(block) {
            if !visited.contains(&succ) {
                queue.push_back(succ);
            }
        }
    }

    Ok(visited.into_iter().collect())
}

fn block_successors(block: &HirBlock) -> Vec<BlockId> {
    let mut successors = Vec::new();
    for node in &block.nodes {
        if let HirKind::Terminator(term) = &node.kind {
            match term {
                HirTerminator::If {
                    then_block,
                    else_block,
                    ..
                } => {
                    successors.push(*then_block);
                    if let Some(else_block) = else_block {
                        successors.push(*else_block);
                    }
                }
                HirTerminator::Match {
                    arms,
                    default_block,
                    ..
                } => {
                    for arm in arms {
                        successors.push(arm.body);
                    }
                    if let Some(default_block) = default_block {
                        successors.push(*default_block);
                    }
                }
                HirTerminator::Loop { body, label, .. } => {
                    successors.push(*body);
                    successors.push(*label);
                }
                HirTerminator::Break { target } | HirTerminator::Continue { target } => {
                    successors.push(*target);
                }
                HirTerminator::Return(_)
                | HirTerminator::ReturnError(_)
                | HirTerminator::Panic { .. } => {}
            }
        }
    }
    successors
}

fn scan_expr(expr: &HirExpr, uses_template_results: &mut bool) {
    match &expr.kind {
        HirExprKind::HeapString(_) => {
            *uses_template_results = true;
        }
        HirExprKind::Load(place) | HirExprKind::Move(place) => {
            scan_place(place, uses_template_results);
        }
        HirExprKind::BinOp { left, right, .. } => {
            scan_expr(left, uses_template_results);
            scan_expr(right, uses_template_results);
        }
        HirExprKind::UnaryOp { operand, .. } => {
            scan_expr(operand, uses_template_results);
        }
        HirExprKind::Call { args, .. } => {
            for arg in args {
                scan_expr(arg, uses_template_results);
            }
        }
        HirExprKind::MethodCall { receiver, args, .. } => {
            scan_expr(receiver, uses_template_results);
            for arg in args {
                scan_expr(arg, uses_template_results);
            }
        }
        HirExprKind::StructConstruct { fields, .. } => {
            for (_, value) in fields {
                scan_expr(value, uses_template_results);
            }
        }
        HirExprKind::Collection(items) => {
            for item in items {
                scan_expr(item, uses_template_results);
            }
        }
        HirExprKind::Range { start, end } => {
            scan_expr(start, uses_template_results);
            scan_expr(end, uses_template_results);
        }
        HirExprKind::Int(_)
        | HirExprKind::Float(_)
        | HirExprKind::Bool(_)
        | HirExprKind::StringLiteral(_)
        | HirExprKind::Char(_)
        | HirExprKind::Field { .. } => {}
    }
}

fn scan_place(place: &HirPlace, uses_template_results: &mut bool) {
    match place {
        HirPlace::Var(_) => {}
        HirPlace::Field { base, .. } => scan_place(base, uses_template_results),
        HirPlace::Index { base, index } => {
            scan_place(base, uses_template_results);
            scan_expr(index, uses_template_results);
        }
    }
}

fn scan_terminator(
    terminator: &HirTerminator,
    locals: &mut HashSet<InternedString>,
    uses_template_results: &mut bool,
    params: &HashSet<InternedString>,
) {
    match terminator {
        HirTerminator::If { condition, .. } => {
            scan_expr(condition, uses_template_results);
        }
        HirTerminator::Match {
            scrutinee,
            arms,
            ..
        } => {
            scan_expr(scrutinee, uses_template_results);
            for arm in arms {
                match &arm.pattern {
                    crate::compiler::hir::nodes::HirPattern::Literal(expr) => {
                        scan_expr(expr, uses_template_results);
                    }
                    crate::compiler::hir::nodes::HirPattern::Range { start, end } => {
                        scan_expr(start, uses_template_results);
                        scan_expr(end, uses_template_results);
                    }
                    crate::compiler::hir::nodes::HirPattern::Wildcard => {}
                }
                if let Some(guard) = &arm.guard {
                    scan_expr(guard, uses_template_results);
                }
            }
        }
        HirTerminator::Loop {
            binding,
            iterator,
            index_binding,
            ..
        } => {
            if let Some((name, _)) = binding {
                if !params.contains(name) {
                    locals.insert(*name);
                }
            }
            if let Some(index_name) = index_binding {
                if !params.contains(index_name) {
                    locals.insert(*index_name);
                }
            }
            if let Some(iterator_expr) = iterator {
                scan_expr(iterator_expr, uses_template_results);
            }
        }
        HirTerminator::Return(values) => {
            for value in values {
                scan_expr(value, uses_template_results);
            }
        }
        HirTerminator::ReturnError(expr) => {
            scan_expr(expr, uses_template_results);
        }
        HirTerminator::Panic { message } => {
            if let Some(expr) = message {
                scan_expr(expr, uses_template_results);
            }
        }
        HirTerminator::Break { .. } | HirTerminator::Continue { .. } => {}
    }
}

fn sanitize_identifier(raw: &str) -> String {
    let mut result = String::new();
    let mut chars = raw.chars();
    if let Some(first) = chars.next() {
        if is_identifier_start(first) {
            result.push(first);
        } else {
            result.push('_');
            if is_identifier_continue(first) {
                result.push(first);
            }
        }
        for ch in chars {
            if is_identifier_continue(ch) {
                result.push(ch);
            } else {
                result.push('_');
            }
        }
    }

    if result.is_empty() {
        result.push('_');
    }

    if is_reserved_word(&result) {
        result.insert(0, '_');
    }

    result
}

fn is_identifier_start(ch: char) -> bool {
    ch.is_ascii_alphabetic() || ch == '_' || ch == '$'
}

fn is_identifier_continue(ch: char) -> bool {
    ch.is_ascii_alphanumeric() || ch == '_' || ch == '$'
}

fn is_reserved_word(word: &str) -> bool {
    matches!(
        word,
        "await"
            | "break"
            | "case"
            | "catch"
            | "class"
            | "const"
            | "continue"
            | "debugger"
            | "default"
            | "delete"
            | "do"
            | "else"
            | "export"
            | "extends"
            | "false"
            | "finally"
            | "for"
            | "function"
            | "if"
            | "import"
            | "in"
            | "instanceof"
            | "new"
            | "null"
            | "return"
            | "super"
            | "switch"
            | "this"
            | "throw"
            | "true"
            | "try"
            | "typeof"
            | "var"
            | "void"
            | "while"
            | "with"
            | "yield"
            | "let"
            | "enum"
            | "implements"
            | "interface"
            | "package"
            | "private"
            | "protected"
            | "public"
            | "static"
    )
}

fn format_bin_op(left: &str, op: BinOp, right: &str) -> String {
    match op {
        BinOp::Add => format!("({} + {})", left, right),
        BinOp::Sub => format!("({} - {})", left, right),
        BinOp::Mul => format!("({} * {})", left, right),
        BinOp::Div => format!("({} / {})", left, right),
        BinOp::Mod => format!("({} % {})", left, right),
        BinOp::Eq => format!("({} === {})", left, right),
        BinOp::Ne => format!("({} !== {})", left, right),
        BinOp::Lt => format!("({} < {})", left, right),
        BinOp::Le => format!("({} <= {})", left, right),
        BinOp::Gt => format!("({} > {})", left, right),
        BinOp::Ge => format!("({} >= {})", left, right),
        BinOp::And => format!("({} && {})", left, right),
        BinOp::Or => format!("({} || {})", left, right),
        BinOp::Root => format!("Math.pow({}, 1 / {})", left, right),
        BinOp::Exponent => format!("({} ** {})", left, right),
    }
}

fn format_unary_op(op: UnaryOp, operand: &str) -> String {
    match op {
        UnaryOp::Neg => format!("(-{})", operand),
        UnaryOp::Not => format!("(!{})", operand),
    }
}

fn format_js_string(value: &str) -> String {
    format!("\"{}\"", escape_js_string(value))
}

fn escape_js_string(value: &str) -> String {
    let mut escaped = String::new();
    for ch in value.chars() {
        match ch {
            '"' => escaped.push_str("\\\""),
            '\\' => escaped.push_str("\\\\"),
            '\n' => escaped.push_str("\\n"),
            '\r' => escaped.push_str("\\r"),
            '\t' => escaped.push_str("\\t"),
            '\u{08}' => escaped.push_str("\\b"),
            '\u{0c}' => escaped.push_str("\\f"),
            '\0' => escaped.push_str("\\0"),
            ch if ch.is_ascii_graphic() || ch == ' ' => escaped.push(ch),
            ch => escaped.push_str(&format!("\\u{{{:x}}}", ch as u32)),
        }
    }
    escaped
}

fn format_property_access(base: &str, field: &str) -> String {
    if is_valid_js_identifier(field) {
        format!("({}).{}", base, field)
    } else {
        format!("({})[{}]", base, format_js_string(field))
    }
}

fn format_js_property_name(field: &str) -> String {
    if is_valid_js_identifier(field) {
        field.to_owned()
    } else {
        format_js_string(field)
    }
}

fn is_valid_js_identifier(name: &str) -> bool {
    let mut chars = name.chars();
    let Some(first) = chars.next() else {
        return false;
    };
    if !is_identifier_start(first) {
        return false;
    }
    if chars.any(|ch| !is_identifier_continue(ch)) {
        return false;
    }
    !is_reserved_word(name)
}
