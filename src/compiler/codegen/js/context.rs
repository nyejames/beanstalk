//! Lowers HIR to JavaScript source code.
//!
//! The HIR is a control-flow graph, so we emit a block-dispatch state machine
//! (`while (true)` + `switch (__bst_block)`) rather than rebuilding structured JS.
//! This keeps non-structured jumps (`break`, `continue`, early returns) faithful,
//! and lets us gate small runtime helpers behind analysis flags.

use crate::compiler::compiler_errors::CompilerError;
use crate::compiler::datatypes::DataType;
use crate::compiler::hir::nodes::{
    BlockId, HirBlock, HirExpr, HirExprKind, HirKind, HirModule, HirPlace, HirStmt, HirTerminator,
};
use crate::compiler::parsers::ast_nodes::Var;
use crate::compiler::string_interning::{InternedString, StringTable};
use crate::return_compiler_error;
use crate::settings::IMPLICIT_START_FUNC_NAME;
use std::collections::HashSet;

use super::analysis::{FunctionAnalysis, analyze_function};
use super::formatting::{
    format_bin_op, format_js_property_name, format_js_string, format_property_access,
    format_unary_op,
};
use super::identifiers::JsIdentifierMap;

const INDENT: &str = "    ";
const BLOCK_VAR: &str = "__bst_block";
const TEMPLATE_RESULTS_VAR: &str = "__bst_template_results";
const TEMPLATE_OUTPUT_VAR: &str = "__bst_out";
const HOST_VAR: &str = "__bst_host";
const HOST_IO_FN: &str = "__bst_host_io_functions";
const STRINGIFY_FN: &str = "__bst_stringify";
const LOOP_STATE_VAR: &str = "__bst_loop_state";

#[derive(Debug, Clone)]
pub struct JsModule {
    pub source: String,
    pub entry_function: Option<String>,
    pub exports: Vec<String>,
}

pub fn lower_hir_to_js(
    hir_module: &HirModule,
    string_table: &StringTable,
) -> Result<JsModule, CompilerError> {
    let context = JsCodegenContext::new(string_table);
    context.emit_module(hir_module)
}

struct JsCodegenContext<'a> {
    string_table: &'a StringTable,
    identifiers: JsIdentifierMap,
    output: String,
    indent: usize,
    flags: PreludeFlags,
    exports: Vec<String>,
    entry_function: Option<String>,
}

#[derive(Default)]
struct PreludeFlags {
    uses_host: bool,
    uses_host_io: bool,
    uses_stringify: bool,
}

impl<'a> JsCodegenContext<'a> {
    fn new(string_table: &'a StringTable) -> Self {
        let mut identifiers = JsIdentifierMap::new();
        identifiers.reserve(BLOCK_VAR);
        identifiers.reserve(TEMPLATE_RESULTS_VAR);
        identifiers.reserve(TEMPLATE_OUTPUT_VAR);
        identifiers.reserve(HOST_VAR);
        identifiers.reserve(HOST_IO_FN);
        identifiers.reserve(STRINGIFY_FN);
        identifiers.reserve(LOOP_STATE_VAR);

        JsCodegenContext {
            string_table,
            identifiers,
            output: String::new(),
            indent: 0,
            flags: PreludeFlags::default(),
            exports: Vec::new(),
            entry_function: None,
        }
    }

    fn emit_module(mut self, hir_module: &HirModule) -> Result<JsModule, CompilerError> {
        for node in &hir_module.structs {
            if let HirKind::Stmt(HirStmt::StructDef { name, fields }) = &node.kind {
                self.emit_struct_def(*name, fields)?;
            }
        }

        for node in &hir_module.functions {
            match &node.kind {
                HirKind::Stmt(HirStmt::FunctionDef {
                    name,
                    signature,
                    body,
                }) => {
                    let raw_name = self.string_table.resolve(*name);
                    let js_name = self.identifiers.get(*name, self.string_table);
                    if raw_name == IMPLICIT_START_FUNC_NAME {
                        self.entry_function = Some(js_name.to_owned());
                        self.exports.push(js_name.to_owned());
                    }
                    self.emit_function_def(*name, signature, *body, hir_module.blocks.as_slice())?;
                }
                HirKind::Stmt(HirStmt::TemplateFn { name, params, body }) => {
                    self.flags.uses_stringify = true;
                    self.emit_template_fn(*name, params, *body, hir_module.blocks.as_slice())?;
                }
                _ => {}
            }
        }

        if !self.exports.is_empty() {
            let exports = self.exports.join(", ");
            self.write_line(&format!("export {{ {} }};", exports));
        }

        let mut source = String::new();
        source.push_str(&self.render_prelude());
        source.push_str(&self.output);

        Ok(JsModule {
            source,
            entry_function: self.entry_function,
            exports: self.exports,
        })
    }

    fn render_prelude(&self) -> String {
        let mut prelude = String::new();

        prelude.push_str("// Generated by the Beanstalk compiler.\n");

        if self.flags.uses_host || self.flags.uses_host_io {
            prelude.push_str(&format!(
                "const {} = globalThis.__beanstalk_host || {{}};\n",
                HOST_VAR
            ));
        }

        if self.flags.uses_stringify {
            prelude.push_str(&format!(
                "function {}(value) {{\n{}return value == null ? \"\" : String(value);\n}}\n",
                STRINGIFY_FN, INDENT
            ));
        }

        if self.flags.uses_host_io {
            prelude.push_str(&format!(
                "function {}(value) {{\n{}const io = {}.beanstalk_io;\n{}if (io && typeof io.host_io_functions === \"function\") {{\n{}{}return io.host_io_functions(value);\n{}}}\n{}console.log(String(value));\n}}\n",
                HOST_IO_FN,
                INDENT,
                HOST_VAR,
                INDENT,
                INDENT,
                INDENT,
                INDENT,
                INDENT
            ));
        }

        prelude.push('\n');

        prelude
    }

    fn emit_struct_def(
        &mut self,
        name: InternedString,
        fields: &[Var],
    ) -> Result<(), CompilerError> {
        let js_name = self.identifiers.get(name, self.string_table);
        self.write_line(&format!("function {}(init) {{", js_name));
        self.indent += 1;
        self.write_line("const value = init || {};");
        self.write_line("return {");
        self.indent += 1;
        for field in fields {
            let field_name = self.string_table.resolve(field.id);
            let property = format_js_property_name(field_name);
            self.write_line(&format!(
                "{}: value[{}],",
                property,
                format_js_string(field_name)
            ));
        }
        self.indent -= 1;
        self.write_line("};");
        self.indent -= 1;
        self.write_line("}");
        self.write_line("");
        Ok(())
    }

    fn emit_function_def(
        &mut self,
        name: InternedString,
        signature: &crate::compiler::parsers::statements::functions::FunctionSignature,
        body: BlockId,
        blocks: &[HirBlock],
    ) -> Result<(), CompilerError> {
        let param_ids: Vec<InternedString> =
            signature.parameters.iter().map(|param| param.id).collect();
        let params = param_ids
            .iter()
            .map(|param| self.identifiers.get(*param, self.string_table))
            .collect::<Vec<_>>()
            .join(", ");

        let analysis = analyze_function(body, blocks, &param_ids)?;
        let js_name = self.identifiers.get(name, self.string_table);

        self.write_line(&format!("function {}({}) {{", js_name, params));
        self.indent += 1;
        self.emit_function_locals(&analysis, &param_ids)?;
        self.emit_block_dispatch(body, blocks, &analysis, false)?;
        self.indent -= 1;
        self.write_line("}");
        self.write_line("");
        Ok(())
    }

    fn emit_template_fn(
        &mut self,
        name: InternedString,
        params: &[(InternedString, DataType)],
        body: BlockId,
        blocks: &[HirBlock],
    ) -> Result<(), CompilerError> {
        let param_ids: Vec<InternedString> = params.iter().map(|(id, _)| *id).collect();
        let params = param_ids
            .iter()
            .map(|param| self.identifiers.get(*param, self.string_table))
            .collect::<Vec<_>>()
            .join(", ");

        let analysis = analyze_function(body, blocks, &param_ids)?;
        let js_name = self.identifiers.get(name, self.string_table);

        self.write_line(&format!("function {}({}) {{", js_name, params));
        self.indent += 1;
        self.write_line(&format!("let {} = \"\";", TEMPLATE_OUTPUT_VAR));
        self.emit_function_locals(&analysis, &param_ids)?;
        self.emit_block_dispatch(body, blocks, &analysis, true)?;
        self.indent -= 1;
        self.write_line("}");
        self.write_line("");
        Ok(())
    }

    fn emit_function_locals(
        &mut self,
        analysis: &FunctionAnalysis,
        params: &[InternedString],
    ) -> Result<(), CompilerError> {
        let mut local_names = Vec::new();
        let params_set: HashSet<InternedString> = params.iter().copied().collect();

        for local in &analysis.locals {
            if params_set.contains(local) {
                continue;
            }
            local_names.push(self.identifiers.get(*local, self.string_table));
        }

        local_names.sort();

        if analysis.uses_template_results {
            // Template calls store results in a map so HeapString loads can reuse them.
            self.write_line(&format!(
                "const {} = Object.create(null);",
                TEMPLATE_RESULTS_VAR
            ));
        }

        if analysis.uses_loop_state {
            // Iterator loops need per-header state that survives block dispatch.
            self.write_line(&format!("const {} = Object.create(null);", LOOP_STATE_VAR));
        }

        if !local_names.is_empty() {
            let locals = local_names.join(", ");
            self.write_line(&format!("let {};", locals));
        }

        Ok(())
    }

    fn emit_block_dispatch(
        &mut self,
        entry: BlockId,
        blocks: &[HirBlock],
        analysis: &FunctionAnalysis,
        template_mode: bool,
    ) -> Result<(), CompilerError> {
        let mut block_ids = analysis.block_ids.to_owned();
        block_ids.sort_unstable();

        self.write_line(&format!("let {} = {};", BLOCK_VAR, entry));
        // The dispatcher preserves CFG semantics without reconstructing structured JS.
        self.write_line("while (true) {");
        self.indent += 1;
        self.write_line(&format!("switch ({}) {{", BLOCK_VAR));
        self.indent += 1;

        for block_id in block_ids {
            let block = self.get_block(blocks, block_id)?;
            self.write_line(&format!("case {}:", block_id));
            self.indent += 1;
            self.emit_block_body(block_id, block, blocks, analysis, template_mode)?;
            self.indent -= 1;
        }

        self.write_line("default:");
        self.indent += 1;
        self.write_line(&format!(
            "throw new Error(\"Invalid block id: \" + {});",
            BLOCK_VAR
        ));
        self.indent -= 1;
        self.write_line("}");
        self.indent -= 1;
        self.write_line("}");
        Ok(())
    }

    fn emit_block_body(
        &mut self,
        block_id: BlockId,
        block: &HirBlock,
        blocks: &[HirBlock],
        analysis: &FunctionAnalysis,
        template_mode: bool,
    ) -> Result<(), CompilerError> {
        let mut saw_terminator = false;

        for (index, node) in block.nodes.iter().enumerate() {
            match &node.kind {
                HirKind::Stmt(stmt) => {
                    self.emit_stmt(stmt, template_mode)?;
                }
                HirKind::Terminator(term) => {
                    if index + 1 != block.nodes.len() {
                        return_compiler_error!(
                            "HIR block {} contains nodes after a terminator",
                            block_id
                        );
                    }
                    self.emit_terminator(term, block_id, blocks, analysis, template_mode)?;
                    saw_terminator = true;
                }
            }
        }

        if !saw_terminator {
            if template_mode {
                self.write_line(&format!("return {};", TEMPLATE_OUTPUT_VAR));
            } else {
                self.write_line("return;");
            }
        }

        Ok(())
    }

    fn emit_stmt(&mut self, stmt: &HirStmt, template_mode: bool) -> Result<(), CompilerError> {
        match stmt {
            HirStmt::Assign {
                target,
                value,
                is_mutable: _,
            } => {
                let target_expr = self.emit_place(target)?;
                let value_expr = self.emit_expr(value)?;
                self.write_line(&format!("{} = {};", target_expr, value_expr));
            }
            HirStmt::Call { target, args } => {
                let call = self.emit_call_expr(*target, args)?;
                self.write_line(&format!("{};", call));
            }
            HirStmt::HostCall {
                module,
                import,
                args,
                ..
            } => {
                let call = self.emit_host_call(*module, *import, args)?;
                self.write_line(&format!("{};", call));
            }
            HirStmt::PossibleDrop(_) => {}
            HirStmt::RuntimeTemplateCall {
                template_fn,
                captures,
                ..
            } => {
                let template_name = self.string_table.resolve(*template_fn);
                let template_key = format_js_string(template_name);
                let call = self.emit_call_expr(*template_fn, captures)?;
                self.write_line(&format!(
                    "{}[{}] = {};",
                    TEMPLATE_RESULTS_VAR, template_key, call
                ));
            }
            HirStmt::TemplateFn { .. }
            | HirStmt::FunctionDef { .. }
            | HirStmt::StructDef { .. } => {
                return_compiler_error!(
                    "Nested definition statements are not supported in JS codegen"
                );
            }
            HirStmt::ExprStmt(expr) => {
                let expr_str = self.emit_expr(expr)?;
                if template_mode {
                    self.flags.uses_stringify = true;
                    self.write_line(&format!(
                        "{} += {}({});",
                        TEMPLATE_OUTPUT_VAR, STRINGIFY_FN, expr_str
                    ));
                } else {
                    self.write_line(&format!("{};", expr_str));
                }
            }
        }

        Ok(())
    }

    fn emit_terminator(
        &mut self,
        terminator: &HirTerminator,
        block_id: BlockId,
        blocks: &[HirBlock],
        analysis: &FunctionAnalysis,
        template_mode: bool,
    ) -> Result<(), CompilerError> {
        match terminator {
            HirTerminator::If {
                condition,
                then_block,
                else_block,
            } => {
                let else_target = if let Some(else_block) = else_block {
                    *else_block
                } else {
                    self.infer_if_fallthrough(*then_block, blocks)?
                };
                let cond_expr = self.emit_expr(condition)?;
                self.write_line(&format!("if ({}) {{", cond_expr));
                self.indent += 1;
                self.write_line(&format!("{} = {};", BLOCK_VAR, then_block));
                self.indent -= 1;
                self.write_line("} else {");
                self.indent += 1;
                self.write_line(&format!("{} = {};", BLOCK_VAR, else_target));
                self.indent -= 1;
                self.write_line("}");
                self.write_line("continue;");
            }
            HirTerminator::Break { target } => {
                if let Some(header) = analysis.loop_metadata.header_by_exit.get(target) {
                    if analysis.uses_loop_state {
                        self.write_line(&format!("delete {}[{}];", LOOP_STATE_VAR, header));
                    }
                }
                self.write_line(&format!("{} = {};", BLOCK_VAR, target));
                self.write_line("continue;");
            }
            HirTerminator::Continue { target } => {
                if let Some(header) = analysis.loop_metadata.header_by_body.get(target) {
                    self.write_line(&format!("{} = {};", BLOCK_VAR, header));
                } else {
                    self.write_line(&format!("{} = {};", BLOCK_VAR, target));
                }
                self.write_line("continue;");
            }
            HirTerminator::Return(values) => {
                if values.is_empty() {
                    if template_mode {
                        self.write_line(&format!("return {};", TEMPLATE_OUTPUT_VAR));
                    } else {
                        self.write_line("return;");
                    }
                } else if values.len() == 1 {
                    let value = self.emit_expr(&values[0])?;
                    self.write_line(&format!("return {};", value));
                } else {
                    let value_list = values
                        .iter()
                        .map(|value| self.emit_expr(value))
                        .collect::<Result<Vec<_>, _>>()?
                        .join(", ");
                    self.write_line(&format!("return [{}];", value_list));
                }
            }
            HirTerminator::ReturnError(expr) => {
                let value = self.emit_expr(expr)?;
                self.write_line(&format!("throw {};", value));
            }
            HirTerminator::Panic { message } => {
                if let Some(expr) = message {
                    let value = self.emit_expr(expr)?;
                    self.write_line(&format!("throw new Error({});", value));
                } else {
                    self.write_line("throw new Error(\"panic\");");
                }
            }
            HirTerminator::Loop {
                label,
                binding,
                iterator,
                body,
                index_binding,
            } => {
                self.emit_loop_terminator(
                    block_id,
                    *label,
                    binding,
                    iterator.as_ref(),
                    *body,
                    *index_binding,
                )?;
            }
            HirTerminator::Match { .. } => {
                return_compiler_error!(
                    "JS codegen does not yet support HIR match terminators (block {})",
                    block_id
                );
            }
        }

        Ok(())
    }

    fn emit_loop_terminator(
        &mut self,
        header: BlockId,
        exit: BlockId,
        binding: &Option<(InternedString, DataType)>,
        iterator: Option<&HirExpr>,
        body: BlockId,
        index_binding: Option<InternedString>,
    ) -> Result<(), CompilerError> {
        let Some(iterator_expr) = iterator else {
            self.write_line(&format!("{} = {};", BLOCK_VAR, body));
            self.write_line("continue;");
            return Ok(());
        };

        // Loop headers may run multiple times, so iterator state is cached by header id.
        match &iterator_expr.kind {
            HirExprKind::Range { start, end } => {
                let start_expr = self.emit_expr(start)?;
                let end_expr = self.emit_expr(end)?;
                self.write_line(&format!("if (!{}[{}]) {{", LOOP_STATE_VAR, header));
                self.indent += 1;
                self.write_line(&format!(
                    "{}[{}] = (() => {{ const start = {}; const end = {}; const step = start <= end ? 1 : -1; return {{ kind: \"range\", current: start, end: end, step: step, index: 0 }}; }})();",
                    LOOP_STATE_VAR, header, start_expr, end_expr
                ));
                self.indent -= 1;
                self.write_line("}");
                self.write_line(&format!(
                    "if (({}[{}].step > 0 && {}[{}].current > {}[{}].end) || ({}[{}].step < 0 && {}[{}].current < {}[{}].end)) {{",
                    LOOP_STATE_VAR, header,
                    LOOP_STATE_VAR, header,
                    LOOP_STATE_VAR, header,
                    LOOP_STATE_VAR, header,
                    LOOP_STATE_VAR, header,
                    LOOP_STATE_VAR, header
                ));
                self.indent += 1;
                self.write_line(&format!("delete {}[{}];", LOOP_STATE_VAR, header));
                self.write_line(&format!("{} = {};", BLOCK_VAR, exit));
                self.write_line("continue;");
                self.indent -= 1;
                self.write_line("}");
                if let Some((name, _)) = binding {
                    let js_name = self.identifiers.get(*name, self.string_table);
                    self.write_line(&format!(
                        "{} = {}[{}].current;",
                        js_name, LOOP_STATE_VAR, header
                    ));
                }
                if let Some(index_name) = index_binding {
                    let js_name = self.identifiers.get(index_name, self.string_table);
                    self.write_line(&format!(
                        "{} = {}[{}].index;",
                        js_name, LOOP_STATE_VAR, header
                    ));
                }
                self.write_line(&format!(
                    "{}[{}].current += {}[{}].step;",
                    LOOP_STATE_VAR, header, LOOP_STATE_VAR, header
                ));
                self.write_line(&format!("{}[{}].index += 1;", LOOP_STATE_VAR, header));
            }
            _ => {
                let iter_expr = self.emit_expr(iterator_expr)?;
                self.write_line(&format!("if (!{}[{}]) {{", LOOP_STATE_VAR, header));
                self.indent += 1;
                self.write_line(&format!(
                    "{}[{}] = (() => {{ const value = {}; const length = value && typeof value.length === \"number\" ? value.length : 0; return {{ kind: \"collection\", value: value, index: 0, length: length }}; }})();",
                    LOOP_STATE_VAR, header, iter_expr
                ));
                self.indent -= 1;
                self.write_line("}");
                self.write_line(&format!(
                    "if ({}[{}].index >= {}[{}].length) {{",
                    LOOP_STATE_VAR, header, LOOP_STATE_VAR, header
                ));
                self.indent += 1;
                self.write_line(&format!("delete {}[{}];", LOOP_STATE_VAR, header));
                self.write_line(&format!("{} = {};", BLOCK_VAR, exit));
                self.write_line("continue;");
                self.indent -= 1;
                self.write_line("}");
                if let Some((name, _)) = binding {
                    let js_name = self.identifiers.get(*name, self.string_table);
                    self.write_line(&format!(
                        "{} = {}[{}].value[{}[{}].index];",
                        js_name, LOOP_STATE_VAR, header, LOOP_STATE_VAR, header
                    ));
                }
                if let Some(index_name) = index_binding {
                    let js_name = self.identifiers.get(index_name, self.string_table);
                    self.write_line(&format!(
                        "{} = {}[{}].index;",
                        js_name, LOOP_STATE_VAR, header
                    ));
                }
                self.write_line(&format!("{}[{}].index += 1;", LOOP_STATE_VAR, header));
            }
        }

        self.write_line(&format!("{} = {};", BLOCK_VAR, body));
        self.write_line("continue;");
        Ok(())
    }

    fn emit_call_expr(
        &mut self,
        target: InternedString,
        args: &[HirExpr],
    ) -> Result<String, CompilerError> {
        let raw_name = self.string_table.resolve(target);
        let args_str = args
            .iter()
            .map(|arg| self.emit_expr(arg))
            .collect::<Result<Vec<_>, _>>()?
            .join(", ");

        if raw_name == "host_io_functions" {
            self.flags.uses_host = true;
            self.flags.uses_host_io = true;
            return Ok(format!("{}({})", HOST_IO_FN, args_str));
        }

        let js_name = self.identifiers.get(target, self.string_table);
        Ok(format!("{}({})", js_name, args_str))
    }

    fn emit_host_call(
        &mut self,
        module: InternedString,
        import: InternedString,
        args: &[HirExpr],
    ) -> Result<String, CompilerError> {
        self.flags.uses_host = true;
        let module_name = self.string_table.resolve(module);
        let import_name = self.string_table.resolve(import);
        let args_str = args
            .iter()
            .map(|arg| self.emit_expr(arg))
            .collect::<Result<Vec<_>, _>>()?
            .join(", ");
        Ok(format!(
            "{}[{}][{}]({})",
            HOST_VAR,
            format_js_string(module_name),
            format_js_string(import_name),
            args_str
        ))
    }

    fn emit_expr(&mut self, expr: &HirExpr) -> Result<String, CompilerError> {
        match &expr.kind {
            HirExprKind::Int(value) => {
                if matches!(expr.data_type, DataType::None) {
                    Ok("null".to_owned())
                } else {
                    Ok(value.to_string())
                }
            }
            HirExprKind::Float(value) => Ok(value.to_string()),
            HirExprKind::Bool(value) => Ok(value.to_string()),
            HirExprKind::StringLiteral(value) => {
                let raw = self.string_table.resolve(*value);
                Ok(format_js_string(raw))
            }
            HirExprKind::HeapString(template_fn) => {
                let raw = self.string_table.resolve(*template_fn);
                let key = format_js_string(raw);
                Ok(format!("{}[{}]", TEMPLATE_RESULTS_VAR, key))
            }
            HirExprKind::Char(value) => Ok(format_js_string(&value.to_string())),
            HirExprKind::Load(place) | HirExprKind::Move(place) => self.emit_place(place),
            HirExprKind::Field { base, field } => {
                let base_name = self.identifiers.get(*base, self.string_table);
                let field_name = self.string_table.resolve(*field);
                Ok(format_property_access(&base_name, field_name))
            }
            HirExprKind::BinOp { left, op, right } => {
                let left_expr = self.emit_expr(left)?;
                let right_expr = self.emit_expr(right)?;
                Ok(format_bin_op(&left_expr, *op, &right_expr))
            }
            HirExprKind::UnaryOp { op, operand } => {
                let operand_expr = self.emit_expr(operand)?;
                Ok(format_unary_op(*op, &operand_expr))
            }
            HirExprKind::Call { target, args } => self.emit_call_expr(*target, args),
            HirExprKind::MethodCall {
                receiver,
                method,
                args,
            } => {
                let receiver_expr = self.emit_expr(receiver)?;
                let method_name = self.string_table.resolve(*method);
                let method_expr = format_property_access(&receiver_expr, method_name);
                let args_str = args
                    .iter()
                    .map(|arg| self.emit_expr(arg))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("{}({})", method_expr, args_str))
            }
            HirExprKind::StructConstruct { type_name, fields } => {
                let struct_name = self.identifiers.get(*type_name, self.string_table);
                let mut field_parts = Vec::new();
                for (field_name, value) in fields {
                    let prop = format_js_property_name(self.string_table.resolve(*field_name));
                    let value_expr = self.emit_expr(value)?;
                    field_parts.push(format!("{}: {}", prop, value_expr));
                }
                Ok(format!("{}({{{}}})", struct_name, field_parts.join(", ")))
            }
            HirExprKind::Collection(items) => {
                let items_str = items
                    .iter()
                    .map(|item| self.emit_expr(item))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("[{}]", items_str))
            }
            HirExprKind::Range { start, end } => {
                let start_expr = self.emit_expr(start)?;
                let end_expr = self.emit_expr(end)?;
                Ok(format!("({{ start: {}, end: {} }})", start_expr, end_expr))
            }
        }
    }

    fn emit_place(&mut self, place: &HirPlace) -> Result<String, CompilerError> {
        match place {
            HirPlace::Var(name) => Ok(self.identifiers.get(*name, self.string_table)),
            HirPlace::Field { base, field } => {
                let base_expr = self.emit_place(base)?;
                let field_name = self.string_table.resolve(*field);
                Ok(format_property_access(&base_expr, field_name))
            }
            HirPlace::Index { base, index } => {
                let base_expr = self.emit_place(base)?;
                let index_expr = self.emit_expr(index)?;
                Ok(format!("({})[{}]", base_expr, index_expr))
            }
        }
    }

    fn get_block<'b>(
        &self,
        blocks: &'b [HirBlock],
        id: BlockId,
    ) -> Result<&'b HirBlock, CompilerError> {
        blocks
            .get(id)
            .ok_or_else(|| CompilerError::compiler_error(format!("Invalid HIR block id {}", id)))
    }

    fn infer_if_fallthrough(
        &self,
        then_block: BlockId,
        blocks: &[HirBlock],
    ) -> Result<BlockId, CompilerError> {
        // HIR omits the else block for `if` when control breaks to a fallthrough target.
        let block = self.get_block(blocks, then_block)?;
        for node in block.nodes.iter().rev() {
            if let HirKind::Terminator(HirTerminator::Break { target }) = &node.kind {
                return Ok(*target);
            }
        }
        return_compiler_error!(
            "Cannot infer else target for if statement (then block {})",
            then_block
        )
    }

    fn write_line(&mut self, line: &str) {
        if line.is_empty() {
            self.output.push('\n');
            return;
        }
        for _ in 0..self.indent {
            self.output.push_str(INDENT);
        }
        self.output.push_str(line);
        self.output.push('\n');
    }
}
