[Navbar]

[header center: [title(1): FUNCTIONS]]
[main:
If the function can only return an error, you can use a '?' as the specified return type.

Arguments are passed in as immutable references (or immutable copies) by default, but mutable references can be passed by using the ~ operator to specify mutability.
This can be specified further as being a copy by specifying the type as a copy.

## The arrow operator
The arrow operator is used to define the signature of a function. 

## Functions can encapculate data
By exporting properties out of a function, you can use it to encapculate data.

## methods
There are no methods in a traditional sense, but similar to Rust, you can impliment traits for types by naming an argument of that type with 'self'.

Self arguments cannot have a default value.

[code:
    -- Returns an int
    multipleReturns fn(x Int) -> Int: return 1 + x

    -- Returns a struct
    returnStruct fn(x Int) -> SomeStruct:
        return SomeStruct{1, 2}
    end

    differentReturns fn(spicy bool = false) -> (Int, Int, Int):
        if spicy: return (69, 420, 1337)
        
        return (1, 2, 3)
    end

    canError fn(x String) -> String?:
        return fetch(x) ? error(msg)
    end

    -- Anonymous function
    fn(x Int) -> Int: return x + 1

    -- Shorthand for anonymous function that just returns a single inline expression
    fn: return "Hello, World!"

    -- Calling a function
    multipleReturns(5)

    -- Calling a function with named arguments
    differentReturns(spicy = true)

    increment(self Int, )
]

## Concurrent Functions
In a similar manor to Go. Beanstalk plans on having concurrent functions with message passing.

Concurrent function calls are prefixed with the 'async' keyword.

[code:
    -- Returns an int
    async concurrentFunc fn
]

[Footer]