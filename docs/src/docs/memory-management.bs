[Navbar]

[header center: [title(1): MEMORY MANAGEMENT]]
[main:

[red: Memory management scheme still in testing / design phase ]

# Current ideas about memory management
The intention is for Beanstalk to *not* have a garbage collector. 

There will be need to be safety and avoidance of common bugs without a significant penaulty to how optimized the output can be.

The current plan is to have a system similar to Rust, but with an RC to trade off some performance for some more flexibility and higher developer velocity.

The much simpler type system and language design in general should hopefully curb some of the costs move semantics and being able to eliminate most reference counting 
through move and immutable reference semantics means less complexity and more refactorable code for the developer to deal with than in Rust.

## The current Idea
- Start with a rust style single ownership system
- Immutable and move semantics by default
- All copies are explicit no matter what. Have to use the copy keyword before the type
- The '~' symbol (or tilde) not only means a variable is mutable when declaring, but also is needed to be used when passing variables to functions if they are going to be a mutable reference or pass ownership
- The compiler decides whether it's passing a mutable reference or passing over ownership based on whether the variable is later used in the same scope.
(this might even be simplified to just always being dropped at the end of the scope anyway depending on whether there is a performance benefit to passing ownership over)
- There can be more than one mutable reference passed to a function at a time as the language will need channels (like go) to do concurrency and multithreading. 
- The RC kicks in to only keep track of ambiguous lifetimes cost of the RC overhead.
- Currently don't know what to do about circular references, might have to be something that is statically analysed for at compile time.

[code:

    testing_memory fn(number Int, mutable_number ~Int) =
    
        Coords = (
            x ~= 5,
            y ~= 3,
            swap fn() =
                x = this.x
                this.x = this.y
                this.y = x
            end
        )

        -- Coords 2 is a mutable reference to coords
        Coords2 ~= Coords

        -- A mutable reference to the original Coords is given to change_var
        change_var(~Coords)

        -- Compiler now has to determine how to handle the double mutable reference
        -- It will do this by adding a reference counter that is now keeping track of when neither reference is needed
        -- Using mutliple concurrent threads is an explicit task that will be similar to Go routines in Go.
        change_2_vars(~Coords, ~Coords2)

        -- Creates a new mutable copy
        change_var(copy ~Coords2)

        -- This copy is immutable because no mutability was specified
        copying_a_var copy = Coords
    end

    -- References
    testing_memory_3 fn() -> () =
        var1 = {1, 2, 3}

        -- Mutable Reference to var given to function
        change_var(~var1)

        -- Ownership given back to var1
        -- Because var1 is later used in this scope

        -- Giving var1 to var2 and var3
        var2 = ~var1
        var3 = ~var1

        -- Creating a copy
        var4 copy = ~var1 

        -- Error, var2 was given to var3
        var2 = {4, 5}

        -- 
        change_var(~var1)
    end
]

